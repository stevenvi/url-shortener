import { Client } from 'pg';
import { ApiError, ErrorTypes } from '../errors/Errors';

const PG_COLLISION_ERROR = '23505';

export class ShortenDb {
    readonly dbClient: Client;

    constructor() {
        this.dbClient = new Client();
    }

    /**
     * Connects to the database
     */
    async connect(): Promise<void> {
        return this.dbClient.connect();
    }

    /**
     * Disconnects from the database
     */
    async close(): Promise<void> {
        return this.dbClient.end();
    }

    /**
     * Finds the numeric id associated with a url in the database
     * @param url {string} The url to look up
     * @return The id associated with the url in the database, or undefined if not found
     */
    async getIdForUrl(url: string): Promise<number | undefined> {
        const result = await this.dbClient.query('SELECT id FROM urls WHERE url=$1', [url]);
        return result?.rows?.[0]?.id;
    }

    /**
     * Finds the url associated with a numeric id in the database
     * @param id {number} The id to look up
     * @return The url associated with the id in the database, or undefined if not found
     */
    async getUrlForId(id: number | string): Promise<string | undefined> {
        const result = await this.dbClient.query('SELECT url FROM urls WHERE id=$1', [id as String]);
        return result?.rows?.[0]?.url;
    }

    /**
     * Finds the url associated with a vanity slug in the database
     * @param slug {string} The vanity slug to look up
     * @return The url associated with the vanity slug in the database, or undefined if not found
     */
    async getUrlForVanitySlug(slug: string): Promise<string | undefined> {
        const result = await this.dbClient.query('SELECT url FROM urls u, slugs s WHERE s.slug=$1 AND s.urlId=u.id', [slug]);
        return result?.rows?.[0]?.url;
    }

    /**
     * Finds the numeric id for the vanity slug in the database
     * @param slug {string} The vanity slug to look up
     * @return The numeric id of the url associated with the vanity slug in the database, or undefined if no association exists
     */
    async getUrlIdForVanitySlug(slug: string): Promise<number | undefined> {
        const result = await this.dbClient.query('SELECT urlId FROM slugs WHERE slug=$1', [slug]);
        return result?.rows?.[0]?.urlId;
    }

    /**
     * Inserts a new url into the database, with an optional vanity slug
     * @param url {string} The long url to be inserted into the shortened url database
     * @param [slug] {string} Vanity slug to associate with this url
     * @return The short url slug generated by this insert
     */
    async insertUrl(url: string, slug?: string): Promise<number | string> {
        // Get the id of the url to insert if it already exists, otherwise insert it now
        let id = await this.getIdForUrl(url);
        if (!id) {
            // Does not exist yet, insert now
            try {
                const result = await this.dbClient.query('INSERT INTO urls (url) VALUES ($1) RETURNING id', [url]);
                id = result?.rows?.[0]?.id;
            } catch (e: any) {
                if (e.code === PG_COLLISION_ERROR) {
                    // Collision. Assume a race occurred and another process has inserted this URL.
                    // In this case, we can try to fetch again and we should find it now.
                    id = await this.getIdForUrl(url);
                    if (!id) {
                        throw new ApiError(ErrorTypes.DUPLICATE_KEY, `Insert collision occurred, but offending row cannot be found for url ${url}`);
                    }
                } else {
                    // Unhandled error, rethrow
                    throw e;
                }
            }
        }

        // By this point we should have an id, but in case there's a driver bug, we'll double check
        if (!id) {
            throw new ApiError(ErrorTypes.INSERT_ID_NOT_FOUND);
        }

        // If no vanity slug is requested, we're done
        if (!slug || !slug.trim().length) {
            return id;
        }

        // Add vanity slug to db

        // Check if slug already exists
        if ((await this.getUrlIdForVanitySlug(slug)) !== undefined) {
            // Slug already exists, throw an error
            throw new ApiError(ErrorTypes.DUPLICATE_SLUG);
        }

        // Insert the new slug
        try {
            await this.dbClient.query('INSERT INTO slugs (slug, urlId) VALUES($1, $2)', [slug, id.toString()]);
            return slug;
        } catch (e: any) {
            if (e.code === PG_COLLISION_ERROR) {
                // Collision. Check if by any chance this slug is for the id we are attempting to pair.
                if ((await this.getUrlIdForVanitySlug(slug)) === id) {
                    // It was the same url, the user experience is unaffected
                    return slug;
                } else {
                    // It was not the same url, we must notify the user that a race occurred and they lost
                    throw new ApiError(ErrorTypes.DUPLICATE_SLUG);
                }
            } else {
                // Unknown error, rethrow
                throw e;
            }
        }
    }
}
